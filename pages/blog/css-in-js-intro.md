---
title: CSS-in-JS. Начало
date: '2021-02-15'
tags:
  - css
  - cssinjs
  - react
  - styledcomponents
  - emotion
  - radium
  - jsxstyle
  - jss
---

Это пролог к статье о Styled Components. На момент 15 февраля 2021 года - будущей. Если вам интересно, как мы дошли до жизни такой, рекомендую начать именно отсюда. Сразу задам тон повествования: я предполагаю, что с JavaScript и React вы уже знакомы. Вам сейчас придётся согласиться, что HTML в JS это нормально, а CSS в JS, как минимум, тоже.

## Компонентный подход

Вы все, наверное, слышали понятие «разделение ответственности» (separation of concerns). Для веб-разработки вообще и вёрстки в частности это означало (и до сих пор означает, в целом) следующее: отделение структуры документа от внешнего вида и поведения. HTML отдельно, CSS отдельно, JavaScript отдельно. Но только ли это?

Вот нужна вам кнопка. Что вы делаете? Правильно: определяете её в HTML, составляете стили по её классу в CSS и пишете скрипт:

```html
<!-- index.html -->
<button type="button" id="myButton" class="my-button">
  Нажми меня
</button>

<!-- style.css -->
<style>
  .my-button {
    border: 1px solid cyan;
    background: transparent;
    color: cyan;
  }
</style>

<!-- script.js -->
<script>
  const myButton = document.getElementById('myButton');
  myButton.on('click', () => {
    alert('My click!');
  });
</script>
```

Прекрасно, кнопка есть, можно использовать где угодно. Но где угодно ли? Она вот, в нашем документе лежит. Для начала, её нужно, как минимум, скопировать, а как максимум – озаботиться уникальным идентификатором, набросать классов для различного оформления, дописать JavaScript обработчики на каждую задачу... а потом всё это ещё и поддерживать в разных местах и таскать из проекта в проект. Да что там, даже в рамках одного проекта занятие муторное.

Давайте немного подумаем. А что, если разделение ответственности – оно не про отделение представления и поведения от структуры, а про разбиение большой задачи на куски поменьше, на...

### Компоненты

Каждый компонент решает свой вопрос и решает его хорошо: кнопка по нажатию просто делает, что указано, поле ввода на форме – реагирует на ошибки пользователя, а модальное окно – способно само определить, на каком устройстве оно было открыто. Ответственность разделена? [Вполне](https://speakerdeck.com/didoo/let-there-be-peace-on-css?slide=62){target="_blank"}, просто немного иначе:

![Separation of concerns](/images/soc.png 'Разделение ответственности')

Обратили внимание на цветовую кодировку классического разделения? Она никуда не делась и в компонентном подходе, а буквально **размылась** в нём: компонент должен полностью отвечать за свою структуру, поведение и внешний вид. Это довольно простой концепт, но многим до сих пор тяжело его принять.

### JSX

[React](https://reactjs.org/){target="_blank"} стал одной из первых библиотек (гусары, молчать!) принёсшей компоненты в народ. Концепция JSX - HTML код совмещённый с JavaScript - была [не новой](https://en.wikipedia.org/wiki/ECMAScript_for_XML){target="_blank"}, но создателям React удалось донести её в понятной форме массе веб-разработчиков. Естественно, мир им не ограничивается, просто в рамках данной статьи так удобнее.

JSX по определению решает лишь задачу объединения структуры части документа с поведением этой самой части:

```jsx
export function MyButton(props) {
  return (
    <button type="button" className="my-button" onClick={props.handleClick}>
      Нажми меня
    </button>
  );
}
```

Вопрос же оформления при этом всё ещё открыт и классы наше всё.

### Погоди, а с CSS-то что не так?

Ну вообще-то, много чего:

- Всё написанное вами попадает в глобальную область видимости
- Управление зависимостями напоминает ад
- Отследить неиспользуемый код очень сложно
- Код может стать довольно объёмным. Минификация решает лишь часть проблем (названия классов-то куда девать?)
- Ещё не так давно не было стандартного способа задавать константы
- «Жадность» определений: нам не нужны скруглённые углы и тень в похожей кнопке? придётся их индивидуально сбрасывать
- Возможности управления состоянием стилей из скриптов весьма ограничены: до недавнего времени лучшее, что можно было сделать, это переключить классы
- Ваш прекрасный набор классов для оформления запросто ломает чудак, вооружённый \* и >

![CSS is awesome](/images/awesome.png 'CSS is awesome')

Да, частично это решают препроцессоры. Частично - css-модули. Но хочется чего-то более универсального. И тут...

## CSS в JS

### Do it with style

Мы и раньше могли обращаться к стилям DOM-узлов через свойство style, считывая и устанавливая значение свойства style связанного с узлом элемента:

```javascript
el.style.color = 'white';
el.style.backgroundColor = 'cyan';
```

В итоге мы получаем генерированный атрибут style, который ещё называют __инлайновыми__ стилями:

```html
<div style="color: white; background-color: cyan">
  Hello Styles!
</div>
```

Минусы? Никаких вам псевдоклассов, никаких вам псевдоэлементов, никакой развитой анимации. Об отсутствии централизованного управления внешним видом множества элементов единовременно и объединения стилей (кажется, это худшая в мире ода CSS-классам) можно забыть. И об автоматических браузерных префиксах тоже. Плюсы? Это бронебойно и точно работает (пока кто-нибудь !important не наставил).

### Красивее как-то можно?

В JSX – можно:

```jsx
const divStyle = {
  color: 'white',
  backgroundColor: 'cyan',
};

export function HelloStylesComponent() {
  return <div style={divStyle}>Hello React Styles!</div>;
}
```

Минусы, в целом, всё те же. Но тем не менее, в 2014 году об этом [рассказали](https://speakerdeck.com/vjeux/react-css-in-js){target="_blank"} на одной из первых посвящённых реакту конференций, пригласив сообщество к дискуссии.

### CSS-in-JS

Подход CJS предполагает, что описанные вами стили – неважно, будут они реализованы на CSS-подобном языке или через JS-объекты – применятся к вашим элементам через обычные классы, которые будут автоматически выстраиваться в нужную вам композицию. Вы получаете всё, что имели в CSS, плюс динамические возможности JavaScript.

В очень грубом приближении, при выполнении или сборке вашего кода будут автоматически созданы классы HTML-элементов и создастся тег `<style>` и/или CSS-файл со всеми нужными правилами.

Плюсы:

- Соблюдается принцип единой ответственности: компонент полностью отвечает за свой внешний вид и поведение
- Самоудаление «мёртвого» (неиспользуемого) кода
- Динамические возможности ограничены лишь вашими умениями
- Никаких проблем с именованием классов (вы же уже подумали об имени компонента, наверное)
- Изоляция стилей
- Контроль состояния в любой момент

Минусы:

- Требуется некоторое время на привыкание (например, к синтаксису)
- Лучшие возможности требуют дополнительной настройки сборки
- Сложности с поддержкой редакторами кода (верно не всегда)
- Стили не применятся, пока не выполнится JS (верно не всегда)
- Производительность ниже, чем у классического подхода (верно не всегда)
- Очевидно, стили кешироваться отдельно от скриптов не станут (верно не всегда)

Кстати, в CJS возможна **атомизация** классов, что позволяет сжать ваш код до предела. Представьте себе, что все написанные вами правила сгруппируются и выстроятся в ровную композицию автоматически. Без [Tailwind CSS](https://tailwindcss.com/){target="_blank"} и прочих подходов из нулевых (вы правда думали, что Tailwind первый такой?). Отлаживать это, конечно, будет непросто, зато размер сборки минимальный и скорость максимальна.

Давайте пройдёмся по примерам из нескольких популярных библиотек.

## Что в наличии?

### JSS

Само понятие CSS-in-JS узурпировал (создал?) [JSS](https://cssinjs.org/){target="_blank"}. Первый известный релиз на GitHub датируется 2014 годом сразу с версии 0.2.1, можно предположить, что сама идея зародилась и раньше. Если вы хоть раз использовали [Material UI](https://material-ui.com/){target="_blank"}, вы использовали и JSS. Наверняка не все пытались переопределить встроенные стили их компонентов (если интересно, как-нибудь расскажу), потому давайте взглянем на пример, взят из документации с упрощениями:

```javascript
import jss from 'jss';
import color from 'color';

const styles = {
  '@global': {
    body: {
      color: 'green',
    },
  },
  button: {
    '&:hover': {
      background: 'blue',
    },
  },
  ctaButton: {
    extend: 'button',
    '&:hover': {
      background: color('blue').darken(0.3).hex(),
    },
  },
  '@media (min-width: 1024px)': {
    button: {
      width: 200,
    },
  },
};

const { classes } = jss.createStyleSheet(styles).attach();

document.body.innerHTML = `
  <button class="${classes.button}">Button</button>
  <button class="${classes.ctaButton}">CTA Button</button>
`;
```

Обратили внимание? Тут React отсутствует, подход применим к любой реализации. Ещё мне нравится логотип JSS, он максимально издевательский:

![JSS Logo](/images/jss.png 'JSS is Awesome')

Библиотека до сих пор развивается, существует огромное количество плагинов, можно даже, используя [теговые шаблоны](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/template_strings#%D1%82%D0%B5%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B){target="_blank"} писать обычный CSS. А можно, используя `jss-nested`, обращаться к вложенным компонентам. Но вообще...

Это всё больше похоже на какую-то дикую смесь, чем на CSS. Тут вам на одном уровне даются простые свойства объекта, которые можно переиспользовать и расширять, псевдоклассы/элементы, at-правила, селекторы... Честно говоря, выглядит это всё довольно жутковато. Но многим понравилось (многие JS-программисты в CSS не умеют, простите мне эту вольность), а недостатки и условная сложность JSS открыли дорогу иным решениям. Кстати, всё в том же Material UI [рассматривают](https://github.com/mui-org/material-ui/issues/20012){target="_blank"} возможность замены JSS на Styled Components.

### jsxstyle

[Появился](https://github.com/jsxstyle/jsxstyle){target="_blank"} в 2015 году специально для React (и Preact). Предоставляет набор базовых компонентов, имеющих стили по-умолчанию, и позволяющий их расширять передавая свойства (props) прямо в этот компонент.

| Компонент   | Стили                                         |
| ----------- | --------------------------------------------- |
| Block       | display: block;                               |
| Inline      | display: inline;                              |
| InlineBlock | display: inline-block;                        |
| Row         | display: flex; flex-direction: row;           |
| Col         | display: flex; flex-direction: column;        |
| InlineRow   | display: inline-flex; flex-direction: row;    |
| InlineCol   | display: inline-flex; flex-direction: column; |
| Grid        | display: grid;                                |
| Box         | Без стилей                                    |

Работает это всё как-то так:

```jsx
<Row alignItems="center" padding={15}>
  <Block
    backgroundColor="#EEE"
    borderRadius={5}
    height={64}
    width={64}
    marginRight={15}
    backgroundSize="contain"
    backgroundImage="url(http://graph.facebook.com/justinbieber/picture?type=large)"
  />
  <Col fontFamily="sans-serif" fontSize={16} lineHeight="24px">
    <Block fontWeight={600}>Просто</Block>
    <Block fontStyle="italic">Разработка</Block>
  </Col>
</Row>
```

Ну и свои компоненты уже создаются на их базе:

```jsx
const RedBlock = (props) => <Block {...props} color="red" />;
```

Чтобы указать имя тега, впрочем, тоже нужно передать свойство – `component`. Минусы всё те же, что у JSS: нужно запоминать громоздкий выдуманный API, стили лезут в логику.

### Radium

2014-2016 года выдались щедрыми на различные новые подходы. Вот и [Radium](https://github.com/FormidableLabs/radium){target="_blank"} не отставал. Что они сделали? Они переопределили атрибут style таким образом, чтобы он принимал на вход массив. Вы передаёте в него наборы стилей, а они – применяются в строгом порядке:

```jsx
const styles = {
  base: {
    background: 'blue',
    borderRadius: 4,
    color: 'white',
    ':hover': {
      backgroundColor: 'red',
    },
  },
  block: {
    display: 'block',
    '@media (min-width: 320px)': {
      width: '100%',
    }
  }
};

export function HelloRadiumButton() {
  return (
    return (
      <button
        style={[
          styles.base,
          this.props.block && styles.block
        ]}>
        {this.props.children}
      </button>
    );
  );
}
```

Я намеренно не показываю более сложные примеры, это в общем не имеет смысла. Тем более проект Radium официально закрыт. Хотя всё же покажу один. Используя метод `Radium.getState` можно создать новый элемент основываясь на стиле другого. Например, создать и показать подсказку при наведении на кнопку:

```jsx
return (
  <div>
    <button key="keyForButton" style={[styles.button]}>Hover me!</button>
    {Radium.getState(this.state, 'keyForButton', ':hover') ? (
      <span>{' '}Hovering!</span>
    ) : null}
  </div>
);
```

Надо только не забыть создать определение стилей для `:hover`, даже пустое.

### Styled Components

В разделе о JSS я уже заикнулся о теговых шаблонах. Посмотрите вот на это:

```javascript
const Button = styled.button`
  background-color: papayawhip;
  border-radius: 3px;
  color: palevioletred;
`
```

Если вы прочитали документацию по теговым шаблонам, вы уже в курсе, что код выше – это вполне себе стандарт языка. Мы вызываем функцию, на вход которой подаём строку. И эта строка у нас в примере – некоторый набор CSS-правил, которые можно разобрать и получить те же объекты с правилами, что и в других решениях, после чего выдать имя класса.

Казалось бы, на этом можно остановиться, но создатели [Styled Components](https://github.com/styled-components/styled-components){target="_blank"} решили пойти дальше. Они решили из каждой такой записи генерировать новый компонент. Само название уже на это намекает. Идея проще некуда, но последствия неоценимы.

Да, вы не ошиблись. Вот та вот короткая запись выше – это самый настоящий React-компонент, готовый к использованию. Он принимает на вход все поддерживаемые кнопками атрибуты HTML, даже `class` (`className`) и `style`. А раз это полноценный компонент, наверное и свойства (`props`) можно передать? Ну да, естественно:

```jsx
const Button = styled.button`
  background-color: ${props => props.bgColor || 'cyan'};
  border-radius: 3px;
  color: lavender;
`

export function HelloStyledComponent() {
  return (
    <Button bgColor="red">
      Hello!
    </Button>
  );
}
```

Вы уже, наверное, догадались, что ещё можно сделать, но я оставлю это на другой раз. Пока же важно знать, что Styled Components породили огромное число подражателей. Какие-то из них сильно быстрее SC, какие-то дают ещё больше возможностей и даже могут генерировать CSS-файлы во время сборки, убирая все возможные проблемы с производительностью на корню. Но SC всё ещё живы и процветают, вбирая в себя лучшие идеи.

### Хардкор напоследок

Как я уже сказал, 2014-2016 года были щедры на идеи. Можно было даже на уровне транспилятора всё это решить. Встречайте, [babel-plugin-css-in-js](https://github.com/martinandert/babel-plugin-css-in-js){target="_blank"}. Распыляться не буду, смотрим. Вход:

```jsx
const styles = cssInJS({
  button: {
    padding: 5,
    backgroundColor: "blue"
  }
});

<Button className={styles.button} />
```

Выход, JavaScript:

```jsx
const styles = {
  button: "example_js_styles_button"
};

<Button className={styles.button} />
```

CSS:

```css
.example_js_styles_button {
  padding: 5px;
  background-color: blue;
}
```

Самое прекрасное, это всё происходит на этапе сборки и попадает в отдельный файл. Без накладных расходов. Штука интересная, но никаких динамических возможностей не предоставляет.

## Итого

Как видим, существует множество CSS-in-JS фреймворков и библиотек, но лишь одна из них, благодаря своей потрясающе простой идее, создала вокруг себя некий культ. И это – Styled Components. Вся идея, как было сказано в прологе, укладывается в названии, а число подражателей и последователей – весьма велико: [Emotion](https://emotion.sh/){target="_blank"}, [astroturf](https://github.com/4Catalyzer/astroturf){target="_blank"}, [linaria](https://linaria.dev/){target="_blank"}. В следующей статье познакомимся со Styled Components поближе.
