---
title: CSS-in-JS. Начало
date: '2021-01-30'
tags:
  - css
  - cssinjs
  - react
  - styledcomponents
  - glamorous
  - emotion
  - jss
---

Это пролог к статье о Styled Components. Если вам интересно, как мы дошли до жизни такой, рекомендую начать именно отсюда. Сразу задам тон повествования: я предполагаю, что с JavaScript и React вы уже знакомы. Вам сейчас придётся согласиться, что HTML в JS это нормально, а CSS в JS, как минимум, тоже.

Вы все, наверное, слышали понятие "разделение ответственности" (separation of concerns). Для веб-разработки вообще и вёрстки в частности это означало (и до сих пор означает, в целом) следующее: отделение структуры документа от внешнего вида и поведения. HTML отдельно, CSS отдельно, JavaScript отдельно. Только ли?

## Компонентный подход

Вот нужна вам кнопка. Что вы делаете? Правильно: определяете её в HTML, составляете стили по её классу в CSS и пишете скрипт:

```html
<!-- index.html -->
<button type="button" id="myButton" class="my-button">
  Нажми меня
</button>

<!-- style.css -->
<style>
  .my-button {
    border: 1px solid cyan;
    background: transparent;
    color: cyan;
  }
</style>

<!-- script.js -->
<script>
  const myButton = document.querySelector('#myButton');
  myButton.on('click', () => {
    alert('My click!');
  });
</script>
```

Прекрасно, кнопка есть, можно использовать где угодно. Но где угодно ли? Она вот, в нашем документе лежит. Для начала, её нужно, как минимум, скопировать, а как максимум – озаботиться уникальным идентификатором, набросать классов для различного оформления, дописать JavaScript обработчики на каждую задачу... а потом всё это ещё и поддерживать в разных местах и таскать из проекта в проект. Да что там, даже в рамках одного проекта занятие муторное.

Давайте немного подумаем. А что, если разделение ответственности – оно не про отделение представления и поведения от структуры, а про разбиение большой задачи на куски поменьше, на... компоненты?

### Компоненты

Каждый компонент решает свой вопрос и решает его хорошо: кнопка по нажатию просто делает, что указано, поле ввода на форме – реагирует на ошибки пользователя, а модальное окно – способно само определить, на каком устройстве оно было открыто. Ответственность разделена? [Вполне](https://speakerdeck.com/didoo/let-there-be-peace-on-css?slide=62), просто немного иначе:

![Separation of conserns](/images/soc.png 'Разделение ответственности')

Обратили внимание на цветовую кодировку классического разделения? Она никуда не делась и в компонентном подходе, а буквально __размылась__ в нём: компонент должен полностью отвечать за свою структуру, поведение и внешний вид.

### JSX

[React](https://reactjs.org/) стал одним из первых фреймворков принёсший компоненты в массы. Концепция JSX - HTML код совмещённый с JavaScript - была [не новой](https://en.wikipedia.org/wiki/ECMAScript_for_XML), но создателям React удалось донести её в понятной форме массе веб-разработчиков. Естественно мир им не ограничивается, просто в рамках данной статьи так удобнее.

JSX по определению решает лишь задачу объединения структуры части документа с поведением этой самой части:

```jsx
function MyButton(props) {
  return (
    <button type="button" className="my-button" onClick={props.handleClick}>
      Нажми меня
    </button>
  );
}
```

Вопрос же оформления при этом всё ещё открыт.

### Погоди, а с CSS-то что не так?

Да вообще-то, много чего:

* Всё написанное вами попадает в глобальную область видимости
* Управление зависимостями напоминает ад
* Отследить неиспользуемый код очень сложно
* Код может стать довольно объёмным. Минификация решает лишь часть проблем (названия классов-то куда девать?)
* Ещё не так давно не было стандартного способа задавать константы
* "Жадность" определений: нам не нужны скруглённые углы и тень в похожей кнопке? придётся их индивидуально сбрасывать
* Возможности управления состоянием стилей из скриптов весьма ограничены: до недавнего времени лучшее, что можно было сделать, это переключить классы
* Ваш прекрасный набор классов для оформления запросто ломает чудак, вооружённый * и >

Да, частично это решают препроцессоры. Частично - css-модули. Но хочется чего-то более универсального. И тут...

## CSS в JS

### Do it with style

Мы и раньше могли обращаться к стилям DOM-узлов через свойство style, считывая и устанавливая значение атрибута style связанного с узлом элемента:

```javascript
el.style.color = 'white';
el.style.backgroundColor = 'cyan';
```

В итоге мы получаем генерированный атрибут style, который ещё называют инлайновыми стилями:

```html
<div style="color: white; background-color: red">
  Hello Styles!
</div>
```

Минусы? Никаких вам псевдоклассов, никаких вам псевдоэлементов, никакой развитой анимации. Об отсутствии централизованного управления внешним видом множества элементов единовременно и объединения стилей (кажется, это худшая в мире ода CSS-классам) можно забыть. И об автоматических браузерных префиксах тоже. Плюсы? Это бронебойно и точно работает (пока кто-нибудь !important не наставил).

### Красивее как-то можно?

В JSX – можно:

```jsx
const divStyle = {
  color: 'white',
  backgroundColor: 'cyan',
}

function HelloStylesComponent() {
  return (
    <div style={divStyle}>
      Hello React Styles!
    </div>
  );
}
```

Минусы, в целом, всё те же.

### CSS-in-JS

Да, выглядит получше. Да, можно переиспользовать. Нет, остальное всё точно так же. Но этот раздел называется "CSS в JS", а не Style-in-JS. Подход CSS-in-JS предполагает, что описанные вами стили – неважно, будут они реализованы на CSS-подобном языке или через JS-объекты – применятся к вашим элементам через обычные классы. Вы получаете всё, что имели в CSS, плюс динамические возможности JavaScript.

В очень грубом приближении, при выполнении или сборке вашего кода будут автоматически созданы классы HTML-элементов и создастся тег `<style>` и/или CSS-файл со всеми нужными правилами.

Плюсы:

- Соблюдается принцип единой ответственности: компонент полностью отвечает за свой внешний вид и поведение
- Самоудаление "мёртвого" (неиспользуемого) кода
- Динамические возможности ограничены лишь вашими умениями
- Никаких проблем с именованием классов (вы же уже подумали об имени компонента, наверное)
- Изоляция стилей
- Контроль состояния в любой момент

Минусы:

- Требуется некоторое время на привыкание (например, к синтаксису)
- Лучшие возможности требуют дополнительной настройки сборки
- Сложности с поддержкой редакторами кода (верно не всегда)
- Стили не применятся, пока не выполнится JS (верно не всегда)
- Производительность ниже, чем у классического подхода (верно не всегда)
- Очевидно, стили кешироваться отдельно от скриптов не станут (верно не всегда)

Давайте пройдёмся по примерам из нескольких популярных библиотек.

## Что в наличии?

### JSS

Само понятие CSS-in-JS узурпировал (создал?) [JSS](https://cssinjs.org/). Первый известный релиз на GitHub датируется 2014 годом сразу с версии 0.2.1, можно предположить, что сама идея зародилась и раньше. Если вы хоть раз использовали [Material UI](https://material-ui.com/), вы использовали и JSS. Наверняка не все пытались переопределить встроенные стили встроенных компонентов, потому давайте взглянем на пример, взят из документации с упрощениями:

```javascript
import jss from 'jss'
import preset from 'jss-preset-default'
import color from 'color'

// One time setup with default plugins and settings.
jss.setup(preset())

const styles = {
  '@global': {
    body: {
      color: 'green'
    },
    a: {
      textDecoration: 'underline'
    }
  },
  button: {
    fontSize: 12,
    '&:hover': {
      background: 'blue'
    }
  },
  ctaButton: {
    extend: 'button',
    '&:hover': {
      background: color('blue')
        .darken(0.3)
        .hex()
    }
  },
  '@media (min-width: 1024px)': {
    button: {
      width: 200
    }
  }
}

const {classes} = jss.createStyleSheet(styles).attach()

document.body.innerHTML = `
  <button class="${classes.button}">Button</button>
  <button class="${classes.ctaButton}">CTA Button</button>
`
```

Обратили внимание? Тут React отсутствует, а это означает, что подход применим к любой реализации. Есть вывод в HTML? Есть и JSS!

Сразу бросается в глаза, что больше похоже на какую-то дикую смесь, чем на CSS. Тут вам на одном уровне даются простые свойства объекта, которые можно переиспользовать и расширять, псевдоклассы/элементы, at-правила, селекторы... Честно говоря, выглядит это всё довольно жутковато. Но многим понравилось, а недостатки и условная сложность JSS открыли дорогу иным решениям. Кстати, всё в том же Material UI [рассматривают](https://github.com/mui-org/material-ui/issues/20012) возможность замены JSS на Styled Components.

### jsxstyle

[Появился](https://github.com/jsxstyle/jsxstyle) в 2015 году специально для React (и Preact). 

```jsx
<Row alignItems="center" padding={15}>
  <Block
    backgroundColor="#EEE"
    boxShadow="inset 0 0 0 1px rgba(0,0,0,0.15)"
    borderRadius={5}
    height={64}
    width={64}
    marginRight={15}
    backgroundSize="contain"
    backgroundImage="url(http://graph.facebook.com/justinbieber/picture?type=large)"
  />
  <Col fontFamily="sans-serif" fontSize={16} lineHeight="24px">
    <Block fontWeight={600}>Justin Bieber</Block>
    <Block fontStyle="italic">Canadian</Block>
  </Col>
</Row>
```

Использование:

```jsx
const RedBlock = (props) => <Block {...props} color="red" />;
```

### Radium

https://github.com/FormidableLabs/radium 2015 год

### Aphrodite

https://github.com/Khan/aphrodite 2016 год

### Styled Components

https://github.com/styled-components/styled-components 2016 год

### Хардкор напоследок

https://github.com/martinandert/babel-plugin-css-in-js

## Итого

Как видим, существует множество CSS-in-JS фреймворков и библиотек, но лишь одна из них, благодаря своей потрясающе простой идее, создала вокруг себя некий культ. И это – Styled Components. Вся идея, как было сказано в прологе, укладывается в названии, а число подражателей и последователей – весьма велико: [Emotion](https://emotion.sh/), [astroturf](https://github.com/4Catalyzer/astroturf), [linaria](https://linaria.dev/). В следующей статье познакомимся со Styled Components поближе.